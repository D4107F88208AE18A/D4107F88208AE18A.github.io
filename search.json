[{"title":"iptables四表五链","path":"/2024/01/01/iptables四表五链/","content":"参考资料 The iptables tutorial Secure use of iptables and connection tracking helpers Set up an gateway for home or office with iptables","categories":["脚本语言"]},{"title":"文件描述符","path":"/2023/10/09/文件描述符/","content":"文件描述符&amp;文件句柄常用命令：lsof - 列出所有正在使用的文件Linux理念：一切皆文件。 打印网络信息日常使用命令netstat -anp命令获取网络信息，但lsof -i命令也能完成相同的事情。甚至能做的更好 1234567891011121314root@verdaccio:~# lsof -iCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 3891 root 4u IPv4 35503 0t0 TCP *:4873 (LISTEN)docker-pr 3898 root 4u IPv6 41030 0t0 TCP *:4873 (LISTEN)sshd 393867 root 3u IPv4 3127835 0t0 TCP *:ssh (LISTEN)sshd 393867 root 4u IPv6 3127837 0t0 TCP *:ssh (LISTEN)chronyd 393883 _chrony 5u IPv4 3129373 0t0 UDP localhost:323chronyd 393883 _chrony 6u IPv6 3129374 0t0 UDP ip6-localhost:323systemd-r 393992 systemd-resolve 13u IPv4 3127227 0t0 UDP localhost:domainsystemd-r 393992 systemd-resolve 14u IPv4 3127228 0t0 TCP localhost:domain (LISTEN)sshd 406304 root 4u IPv4 3246101 0t0 TCP verdaccio:ssh-&gt;10.40.1.247:37758 (ESTABLISHED)sshd 406413 licanhong 4u IPv4 3246101 0t0 TCP verdaccio:ssh-&gt;10.40.1.247:37758 (ESTABLISHED)sshd 406449 root 4u IPv4 3246162 0t0 TCP verdaccio:ssh-&gt;10.40.1.247:32509 (ESTABLISHED)sshd 406508 licanhong 4u IPv4 3246162 0t0 TCP verdaccio:ssh-&gt;10.40.1.247:32509 (ESTABLISHED) 下述为lsof -i命令的变种，可以更直观的呈现输出的网络信息。 123456789101112131415161718# 打印IPv4流量网络信息lsof -i4# 打印IPv6流量网络信息lsof -i6# 指定IP地址lsof -i @10.40.1.247# TCP协议且端口为22lsof -i TCP:22# 指定IP地址、协议和端口lsof -i TCP@verdaccio:22# 查看指定端口的网络信息lsof -i TCP:10-30 打印指定用户的文件可以通过lsof -u命令查阅指定用户打开的文件， 123456789101112131415# 查看单个用户打开的文件，参数可为username或者uidlsof -u rootlsof -u 0# 查看多个用户打开的文件，参数列表由逗号分隔不应有空格lsof -u 0,licanhong# 显示除指定用户以外的其它所有用户打开的文件列表lsof -u ^root# 显示指定用户打开的所有进程PID# 等同于 lsof -u licanhong | awk &#x27;&#123;print $2&#125;&#x27; | uniq | grep -v PIDlsof -t -u licanhong# 这个命令在强制删除用户但仍有进程没有关闭的情况下可用于杀掉所有用户进程kill -9 `lsof -t -u licanhong` 打印进程信息1、打印进程号信息，可管道传递给kill命令 123456789# 该命令单取PID列的值（去重），常常用于传递给kill命令作参数使用lsof -t# 查看指定进程打开的所有文件lsof -p 407216# 查看指定命令（模糊匹配）打开的文件lsof -c ssh 恢复RM -RF删除的文件通过lsof查找&#x2F;proc&#x2F;[PID]&#x2F;fd&#x2F;下的文件参考链接：https://blog.csdn.net/a772304419/article/details/132390769 句柄泄露文件使用完，但是没有关闭流即文件读取后，还占用着文件参考链接：https://blog.csdn.net/li644872790/article/details/130251383 注：存在几率恢复rm -rf删除的文件！！ 句柄泄露等！ FD要怎么看？？？？"},{"title":"Bacula 开源网络备份解决方案","path":"/2023/07/22/bacula开源备份解决方案/","content":"作为运维人员，对于信息系统的日常备份也是重中之重！只有做好备份再应对数据丢失情况才能最大程度减少损失！Bacula是一个C&#x2F;S结构的网络备份解决方案 传统备份的缺点：1、分散在各个服务器上，通过Shell脚本甚至是人工进行备份！无法集中管控备份结果！ Bacula 五个关键组件 Director Daemon: 管理进程，负责备份服务调度等(bacula-dir.conf) Console：管理控制台，供管理员链接到Director Daemon执行管理操作。(bconsole.conf) File Daemon: 安装在需要备份的机器上，备份时负责将数据传出、恢复时负责接收数据(bacula-fd.conf) Monitor：监控Director、File、Storage三个进程的健康状态 Storage：安装在备份服务器上，备份时将备份数据写入备份服务器，恢复时将数据传输给File Daemon(bacula-sd.conf) File Daemon和Storage是一对的关系！！！ bacula安装教程（包管理器方式安装）：https://bacula.org/whitepapers/CommunityInstallationGuide.pdf 初始账号密码：admin&#x2F;admin bacula API和WEB安装教程：https://www.bacula.org/13.0.x-manuals/en/console/Baculum_API_Web_GUI_Tools.html 快速入门"},{"title":"Docker 网络驱动程序","path":"/2023/03/22/Docker-网络驱动程序/","content":"软件用起来才有价值，才有改进的机会。 -- FIT2CLOUD 飞致云 Docker 的网络子系统是可插拔的，使用驱动程序实现；存在以下七种 Docker 驱动程序，由它们提供Docker引擎核心网络功能。Docker默认预置三种网络，分别为：none、host和bridge。 12345[root@localhost ~]# docker network lsNETWORK ID NAME DRIVER SCOPE5a24a53e4896 bridge bridge local52dd3de39d6e host host local87cf56a3fc84 none null local Bridge networks网桥是属于数据链路层的设备。若无特殊指定网络驱动，容器默认将创建该类型的网络驱动。Docker服务默认会创建名为docker0的桥接网卡。该网卡连接物理网卡和Docker容器网络驱动，主机和容器之间可以通过docker0网桥相互通信。 使用场景：当应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。工作中常见就是通过一个nginx容器作为代理，将网络请求转发到其它几个不同域名的容器。减少端口的暴露，提供安全性。 Host networking定义：使用该网络驱动程序，容器网络栈不隔离于宿主机（容器共享宿主机的网络空间），其次，容器不会分配到IP地址和MAC地址。适用场景：适用对网络性能有较高要求！由于共享宿主机的网络栈，也共享宿主机的网络端口资源。 12345678910111213# WARNING: Published ports are discarded when using host network mode$ docker run -ti --network host -p 80:80 centos /bin/bashdfa46b380f36608def41719e89073c89eaf1dc469998f0a5ac32bcaac8f2305c# 第一步：创建nginx容器，监听宿主机的80端口# --rm Automatically remove the container when it exits# -d Run container in background and print container ID$ docker run --rm -d --network host --name my_nginx nginx第二步：通过http://localhost:80/访问nginx第三步：打印网络堆栈信息，并查看80端口是否被监听$ ip addr$ netstat -anp | grep 80第四步：停止nginx容器（容器将会被自动删除）$ docker container stop my_nginx Overlay networks（覆盖网络）定义：overlay网络驱动程序连接多个Docker守护进程，主要是提供给docker swarm（当前已淘汰）使用。跨宿主机的Docker容器网络连接，应该是类似于k8s所需要的扁平网络实践：需要一个键值对数据库存储网络信息，需要在守护进程启动时指定键值对数据库的地址和提供本机通信地址给到键值对数据库–cluster-store：指定consul的地址 –cluter-advertise：告知consul本机的通信地址创建overlay网络，并将容器加入到键值对网络当中IPvlan networksipvlan（分L2和L3）ipvlan和macvlan类似，都是从一个物理网卡上虚拟出多个虚拟网卡的技术,区别是macvlan 有自己的mac和ip, 而 ipvlan 和父接口工用mac地址, 拥有自己独立的ip在docker 中创建ipvlan网络模型的时候,选择ipvlan_mode&#x3D;l2 的时候和macvlan 一样可有自己的mac地址, 选择ipvlan_mode&#x3D;l3 的时候会和父接口共享mac地址. Macvlan networksmacvlan（类似于vmware的桥接），每个容器都有自己的mac地址！ 1234# 创建macvlan类型的网络驱动程序docker network create --driver macvlan --subnet=10.10.16.1/24 --gateway=10.10.16.1 -o parent=eth0 macvlan2# 启动容器使用该网络驱动，注意IP冲突docker run -itd --network=macvlan2 --ip=10.10.16.10 centos /bin/bash 在某些交换机，由于端口安全的原因而限制了每个物理端口的最大MAC地址数，在这种情况下，应使用ipvlan。在使用普通dhcp服务器的情况下则需要使用macvlan，因为dhcp服务器要求每个子接口必须要有唯一的mac地址（通过DHCP分配,一个MAC地址只能自动获取一个IP地址,但可以手动设置多个IP地址），这种情况下显然ipvlan不满足要求。 Disable networking for a containernone：即无任何网络驱动程序，无法进行网络通信。创建回环设备 network plugins：docker支持第三方的网络插件，类似于k8s需要的扁平网络就有响应的网络插件解决方案提供，可以下载并浏览官方的使用文档进行网络插件的使用flannel与calico 配置容器使用代理服务器（梯子）：梯子：http://it.sunniwell.net/fuckgfw.pac be aware that：意识到peers：同行platform-agnostic：平台无关concepts：概念manipulates：操纵","categories":["云原生"]},{"title":"Linux 三剑客","path":"/2023/02/25/Linux-三剑客/","content":"Linux三剑客：grep、sed、awk这三个工具关键都在于正则表达式的运用！！ 正则表达式：小钢炮一样的存在！模式匹配替换","categories":["脚本语言"]},{"title":"存储篇之磁盘性能测试","path":"/2023/02/25/存储篇之磁盘性能测试/","content":"测试","categories":["数据存储"]},{"title":"存储篇之网络存储","path":"/2023/02/25/存储篇之网络存储/","content":"ISCSI（块存储）、NFS（文件系统存储）","categories":["数据存储"]},{"title":"存储篇之磁盘冗余阵列","path":"/2023/02/25/存储篇之磁盘冗余阵列/","content":"利用虚拟存储技术将多个磁盘组成磁盘阵列组，以达成提升磁盘读写性能或实现冗余容错的目的。 奇偶校验块容错式磁盘阵列（RAID）使用奇偶校验块实现冗余。如果阵列中的一块磁盘出现故障，工作磁盘中的数据块与奇偶校验块一起来重建丢失的数据。下面的图表每列表示一个磁盘，假设A1&#x3D;00000111、A2&#x3D;00000101以及A3&#x3D;00000000。A1、A2、A3异或得到的Ap等于00000010。如果第二个磁盘出现故障，A2将不能被访问，但是可以通过A1、A3与Ap的异或进行重建：A1 XOR A3 XOR Ap &#x3D; 00000101 123456 冗余磁盘阵列 A1 A2 A3 Ap B1 B2 Bp C1 C2 C3 C4 Cp注：数据块是格式A#，奇偶校验块是Ap 一、RAID常见等级标准RAID由两块或两块以上硬盘组合而成 RAID 0把连续的数据分散到多个磁盘上存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能。理论上性能提升倍数为组成RAID 0磁盘阵列的硬盘个数（由两块及两块以上组成），但实际上会存在其它方面的性能瓶颈。 仅能由两块硬盘组合而成 RAID1通过硬盘数据镜像实现数据的冗余，保护数据安全，在两块盘上产生互为备份的数据。当一个硬盘失效时，系统可以自动切换到镜像硬盘上读&#x2F;写，并且不需要重组失效的数据。 由三块或三块以上硬盘组合而成 RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。磁盘空间利用率要比RAID 1高，存储成本相对较低，通过异或计算奇偶校验信息，当一个硬盘失效时，可以通过校验位重组失效的数据，安全性相比RAID 0高。是运用较多的一种解决方案！！（由三块或三块以上硬盘组成）等同耗费一个硬盘空间存储Raid校验信息，实际上奇偶校验信息分布在组成RAID每一个硬盘上 混合RAID 由三块及三块以上硬盘组合而成 RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。磁盘空间利用率要比RAID 1高，存储成本相对较低，通过异或计算奇偶校验信息，当一个硬盘失效时，可以通过校验位重组失效的数据，安全性相比RAID 0高。是运用较多的一种解决方案！！（由三块或三块以上硬盘组成）等同耗费一个硬盘空间存储Raid校验信息，实际上奇偶校验信息分布在组成RAID每一个硬盘上 二、RAID实现模式根据RAID的实现模式，可分为软件RAID和硬件RAID。硬件RAID由专门的RAID卡实现，软件RAID则由操作系统上的磁盘控制器软件实现。 软件磁盘阵列（Software RAID）优点：成本低缺点： 占用服务器CPU运算能力计算奇偶校验信息，访问速度比较慢。性能和稳定性完全依赖于CPU的运算能力！ 更换硬盘的时候需要通知RAID控制器进行关闭 常见的Linux系统软件RAID工具：mdadm适用场景：预算不足，除了便宜没啥好处。 硬件磁盘阵列（Hardware RAID）优点： 内置处理器，独立于服务器操作系统。不占用服务器CPU运算能力 稳定且读写性能优秀 通过拆卸和更换设备可以轻松更换停机磁盘。适用场景：预算充足，除了贵没坏处。缺点：成本高，价格昂贵。 三、低成本实操 利用虚拟机技术，开展低成本软件RAID测试。比较不同RAID级别下读写性能和冗余备份等场景的表现，并整理一个表格。实验材料如下： 软件RAID磁盘控制器软件：mdadm IO测速工具：fio 环境： 虚拟机一台、虚拟硬盘N块","categories":["数据存储"]},{"title":"Dockfile-构建属于自己的容器镜像","path":"/2023/02/12/Dockfile-构建属于自己的容器镜像/","content":"Dockfile - 构建属于自己的容器镜像官方参考文档：https://docs.docker.com/engine/reference/builder/Docker User Manuals：man 5 dockerfile &ensp;&ensp;Dockerfile 类似于早期 Linux系统中定义编译源代码的 Makefile；Dockerfile描述装配容器镜像的一系列步骤，Docker 可以依据从 Dockerfile 读取的指令自动构建容器镜像。具体步骤如下： 创建编辑 Dockrefile 文件，顾名思义需将文件命名为 Dockerfile 调用 docker build 命令，将包含 Dockerfile 文件的目录路径作为参数（相对路径或绝对路径） Docker 容器引擎依据 Dockerfile 读取的指令自动构建容器镜像。 Dockerfile 格式1234INSTRUCTION argumentsFor example:FROM ubuntu"},{"title":"云原生制品仓库-Harbor","path":"/2023/02/11/云原生制品仓库-Harbor/","content":"云原生制品仓库服务Harbor的核心功能是存储、分发和集中管理Artifact注：Artifact包括容器镜像、Helm Chart、CNAB等 访问控制 资源隔离：Harbor提供了“项目”（project）的概念，每个项目都对应一个和项目名相同的命名空间（namespace）来保存Artifact，每个命名空间都是彼此独立的授权单元，将Artifact隔离开来。注：当使用Docker等命令行工具向Harbor推送和拉取镜像等Artifact时，这个命名空间也是URI的一个组成部分,案例如下：12$ docker login -u licanhong -p xxxxxx docker.gnacoh.com$ docker pull docker.gnacoh.com/itd/ubuntu:latest 授权模型：用户要对项目中的Artifact进行读写，就首先要被管理员添加为项目的成员，具体的权限由成员的角色决定。加入项目的成员可以有以下角色。 项目管理员：管理项目成员，删除项目，管理项目级的策略，读写、删除Artifact及项目中的其他资源。 维护人员：管理项目级的策略，读写、删除Artifact及项目中的其它资源。 开发者：读写Artifact及项目中的其他资源。 访客：对Artifact及项目中的其他资源有读权限。 受限访客：仅用于拉取Artifact，对项目中的其他资源如操作日志（log）没有读权限。 镜像签名用途：用于确保分发过程中Artifact内容的完整性，类似于MD5Docker的内容信任是一个纯粹的客户端配置，用户可以通过在客户端关掉开关，跳过对签名的检查。Harbor为镜像的管理员提供了更强的措施，项目管理员可以通过在项目中配置策略，强制只有已签名的镜像才可以被拉取，无论客户端的配置如何。 镜像扫描用途：用于扫描Artifact中是否存在安全漏洞，内置漏洞扫描器（注：漏洞扫描库是否能够做到定期更新？） 实现原理：Harbor项目与一些安全服务商制定了一套扫描适配器（Scanner Adapter）的标准API。其中包含如何描述自己支持的Artifact类型、与仓库的认证方式，以及触发扫描、查询报告等功能。Harbor可以通过调用这些API驱动扫描器对仓库中的Artifact进行扫描，并得到统一格式的包含详细通用漏洞披露（Common Vulnerabilities Exposures）列表的报告。 高级管理功能 项目存储配额管理 解决痛点：避免由于存储资源被某些用户过度占用而影响其他用户的使用容器镜像是分层存储的，存在共用基础镜像的情况。因此项目存储消耗并不简单等同于项目中各个镜像的大小相加，实际情况是小于或等于各个镜像的大小相加。 Artifact复制策略 Tag保留策略（Artifact保留策略）解决存储配额满了之后没有多余存储资源扩容情况下的繁琐镜像删除腾空间操作 垃圾回收"},{"title":"Gitolite-轻量级Git存储库托管","path":"/2023/01/03/Gitolite-轻量级Git存储库托管/","content":"功能&#x2F;特性注：适合小规模团队！最主要的特性：细粒度的权限控制 ！ 123456Gitolite is an access control layer on top of git.# Control access to many git repositories:# Read Accessread access controlled at the repo level,# Write Accesswrite access controlled at the branch/tag/file/directory level, including who can rewind, create, and delete branches/tags 其它特性： 12345678# 客户端访问服务器上的git，通过一个unix用户实现，非root权限（安全）# hosting user：也就是运行gitolite的用户# git和perl需要预先安装Use a single unix user (&quot;real&quot; user) on the server.# gitolite用户不等同于shell用户（虚拟用户），所以不会有shell权限（较安全）Provide access to many gitolite users:they are not &quot;real&quot; users,so they do not get shell access. Gitolite does not do authentication. It only does authorisation. Gitolite 支持 sshd 和 智能httpd 两种方式的远程访问，并依赖 sshd 和 智能httpd 两种协议的身份验证框架执行身份认证，Gitolite 本身不进行身份认证，只进行授权；实际情况下采用 sshd 的交互场景较为常见。 未安装 Gitolite 的 git hoting 工作流程，如图： 安装 Gitolite 的 git hosting 工作流程，如图： 实际的存储库存放在$HOME&#x2F;repositories目录下，并且带有.git后缀（裸仓库） 安装&#x2F;设定万无一失的安装方法： 123456789101112131415161718# 1.使用root用户创建一个普通用户，作为运行gitolite的hosting useruseradd gitoliteuserpasswd gitoliteuser# 2.切换到这个用户去安装gitolitesu - gitoliteuser# 3.本地主机创建一个密钥对并将公钥~/.ssh/id_rsa.pub拷贝到服务器的/tmp/ron.pub目录下# 4.Download Source codegit clone https://github.com/sitaramc/gitolite# 5.Installcd $HOMEmkdir -p bingitolite/install -to $HOME/bin# 6.设置管理员工作站密钥访问,若丢失私钥可到服务器用此命令重置管理员私钥cd $HOME$HOME/bin/gitolite setup -pk /tmp/ron.pub# 7.验证，有返回就正常了git ls-remote git@server:gitolite-admin The admin repo：gitolite-admin重要：gitolite 日常管理工作都是通过一个 git repository 来实现的，它就是 gitolite-admin . Day-to-day management of a gitolite site is done by cloning the special ‘gitolite-admin’ repo, making appropriate changes to it, and pushing it back to the server In other words, do NOT add new repos or users manually on the server! That is also why you should NEVER touch any of those files yourself, unless you know what you’re doing! 1234567891011121314151617# 1. To clone the admin repo.git clone git@host:gitolite-admin# 2. still in your gitolite-admin clone, from the previous stepcp /tmp/alice.pub keydirgit add keydirgit commit -m &#x27;new user alice&#x27;git pushrepo foo RW+ master = alice R = ron#3. commit and pushgit add conf; git commit -m &#x27;new repo foo&#x27;; git push 配置SSH&#x2F;添加用户1、管理员工作站拉取管理库 2、将每个收到的文件重命名为用户的名称，在末尾添加一个“.pub” 3、将公钥文件加入到keydir目录下，add并提交推送回服务器 规范流程如下： 1234567891011# 克隆管理存储库git clone git@server:gitolite-admin# 重命名公钥文件，方便后续查找mv /tmp/xxx.pub /tmp/username.pub# 将公钥文件加入到keydir目录cp /tmp/username.pub gitolite-admin/keydir/# 提交cd gitolite-admingit add keydirgit commitgit push 删除用户 1234567# 克隆管理存储库git clone git@server:gitolite-admin# 提交cd gitolite-admingit rm keydir/username.pubgit commitgit push 密钥文件不仅可以放在keydir目录下，也可以放在keydir的子目录下 这样子方便你组织密钥文件，当一个用户有多个公钥文件可以创建一个目录来组织 Tips：单个用户多个密钥You can put pubkeys in subdirectories within “keydir&#x2F;“, because the user name is simply the base name of the public key file name. That is, ‘keydir&#x2F;alice.pub’, ‘keydir&#x2F;home&#x2F;alice.pub’, ‘keydir&#x2F;laptop&#x2F;alice.pub’, (or even ‘keydir&#x2F;work&#x2F;desktop&#x2F;alice.pub’ – any number of subdirectory levels are OK) all resolve to user “alice”. 重要：查看用户有哪些存储库的权限！！对于日常运维非常有用！！！ 1234# 终端：ssh gitoliteuser@ecs.gnacoh.com infossh gitoliteuser@ecs.gnacoh.com info# 服务器端：bin/gitolite access -s testing licanhong R 添加存储库1、编辑配置文件.&#x2F;conf&#x2F;gitolite.conf，键入如下文本。一个新存储库至少包含一个任意权限的用户 123# 存储库名称repo &quot;name&quot; RW+ = alice 2、如果要继承以前的存储库的权限的话，直接在旧的存储库名称后加上新的存储库名称 123# 存储库名称repo &quot;old name&quot; &quot;new name&quot; RW+ = alice 注意：存储库那一行可以拥有任意数量的相同权限存储库（权限继承：Rights inherit from），但只能是并列1行。如果分成多行则不生效,如下将导致”old name”仓库失效 如果下一个“repo”行之前没有规则行、配置或选项行，则以静默方式忽略该存储库行。 123repo &quot;old name&quot;repo &quot;new name&quot; RW+ = alice 若一行容纳不下，则可以定义一个存储库组。用户名和仓库名不能用正则表达式匹配多个 123456@repos = repo1@repos = repo2@repos = repo3repo @repos RW+ = alice 删除存储库直接在配置文件移除存储库所在行，并不会删除磁盘中的存储库 你需要在配置文件移除后再到服务器上手动删除它 重命名存储库（注意先后顺序）需要先上服务器把$HOME&#x2F;repositories&#x2F;目录下的存储库的名字重命名，记得保留.git后缀 然后再拉取管理存储库，重命名配置文件里边的存储库名 将现有存储库引入到gitolite（这个操作是很具有推广意义的，如国产数据库需要提供mysql或者oracle数据库迁移到国产数据库的工具）暂时不看，后续再看 “conf”文件（conf&#x2F;gitolite.conf） 定义配置文件语法如下： 1234567891011121314# 用户组，@符号开头@staff = dilbert alice # groups# 存储库组，@符号开头@projects = foo bar# 定义存储库repo @projects baz # repos RW+ = @staff # rules（访问规则） - master = ashok # RW = ashok R = wally option deny-rules = 1 # options config hooks.emailprefix = &#x27;[%GL_REPO] &#x27; # git-config gitolite支持将conf&#x2F;gitolite.conf主配置文件分解成多个子配置文件，在conf&#x2F;gitolite.conf主配置文件通过include关键字引入 1include repos/*.conf 默认以管理存储库为当前目录，为合理克隆管理存储库，应尽量避免使用绝对路径。 对每个配置项展开描述， 组定义：用户组和存储库组的定义是相同的！ 123456@developers = dilbert alice@interns = ashok@staff = @interns @developers # 嵌套组@developers = wally# wally is NOT part of @staff ，定义嵌套组后续再往成员组加用户或存储库则不会生效 特殊组：@all，指的是所有存储库或者所有用户 较为复杂的案例： 12345678repo foo bar #“存储库”行 RW+ = alice @teamleads # “规则”行 - master = dilbert @devteam - refs/tags/v[0-9] = dilbert @devteam RW+ dev/ = dilbert @devteam RW = dilbert @devteam R = @managers 规则行字段：权限字段、zero or more “refex”es、等号、用户组或者用户 权限字段： R, to allow read operations only RW, to allow fast-forward push of a branch, or create new branch&#x2F;tag RW+, to allow pretty much anything – fast-forward, rewind or delete branches or tags - (the minus sign), to deny access. “refex” 字段 将权限管理粒度变细，到分支refs/heads/分支名或者标签refs/tags/标签名，分支名和标签名可以通过正则表达式指定 如果没有提供refex字段，则默认隐含refs/.* 如果refex字段没有以refs&#x2F;或者VREF&#x2F;开头，则假设以refs/heads/为前缀 标签需要为完全限定名称，则必须加上前缀refs/tags/ “conf”文件（conf&#x2F;gitolite.conf） 使用可以在配置文件里边嵌入单元测试，确保配置不会被弄乱！ 个人分支，有需要可以研究下 LDAP继承后续补充 规则累积看不懂，后面搭了环境再看看 FAQ1、丢失管理员的私钥文件 解决办法：重新生成密钥对，然后将公钥复制到服务器上 运行：gitolite setup -pk alice.pub 2、 SSHgitolite是如何创建出虚拟的ssh用户？实际上却只是使用一个ssh普通用户 Use a single unix user (&quot;real&quot; user) on the server 备份：备份思路：将托管的所有代码仓库，克隆一份裸仓库作为备份留存归档 备份脚本123456789101112131415161718#!/bin/sh server=git.sunniwell.netroot_dir=`pwd` echo &quot;whill back in dir: $&#123;root_dir&#125;&quot; ssh &quot;git@$&#123;server&#125;&quot; info | awk &#x27;&#123;print $1$2,$3&#125;&#x27; | grep &quot;^RW&quot; | awk &#x27;&#123;print $2&#125;&#x27; | while read line do echo &quot; &quot; echo &quot;-------------------------------------&quot; if [ ! -d &quot;$&#123;root_dir&#125;/$&#123;line&#125;.git&quot; ]; then echo &quot;repo not init on local, init it ...&quot; mkdir -p &quot;$&#123;root_dir&#125;/$&#123;line&#125;.git&quot; cd &quot;$&#123;root_dir&#125;/$&#123;line&#125;.git&quot; cd .. git clone --mirror &quot;git@$&#123;server&#125;:$&#123;line&#125;.git&quot; else echo &quot;repo already init on local, update it ...&quot; cd &quot;$&#123;root_dir&#125;/$&#123;line&#125;.git&quot; git remote update git gc fi done 对执行备份操作的 Gitolite 用户权限要求如下，将所有仓库的读取权限授权给备份用户： 12repo @all R = backup 简短的正则表达式概述查看ssh的authorized_keys文件， 1、可以理解如何工作在多个虚拟用户，只有一个ssh真实用户 先用真实用户ssh上去，然后执行命令”&#x2F;home&#x2F;git&#x2F;.gitolite&#x2F;src&#x2F;gl-auth-command lijing_1764获取一个经过gitolite限制的虚拟shell 2、限制用户的权限（hooks） 附录： 1、终端克隆托管在gitolite的代码仓库 12# 格式：git clone &quot;hosting user&quot;@server:repogit clone gitoliteuser@ecs.gnacoh.com:aliyun 2、服务器克隆gitolite的代码仓库 12# 格式：git clone server:repogit clone ecs.gnacoh.com:aliyun","categories":["版本管理"]},{"title":"Git2.33+版本代码拉取失败问题定位","path":"/2022/12/13/Git2-33-版本代码拉取失败问题定位/","content":"Git 2.33+ 版本代码拉取失败问题定位原因：OpenSSH 8.7 后的版本放弃了默认的RSA密钥算法支持，而 Git 2.33+ 后的版本内置的 OpenSSH 版本高于8.7 导致代码拉取失败；在 Git 安装过程中存在步骤 Choosing the SSH executable，包含如下两个选项： Use bundled OpenSSH Use external OpenSSH 默认为第一选项，使用 Git 自带的 OpenSSH ；可变更为第二选项，使用外部安装的 OpenSSH 解决方法： 一、重新启用 RSA&#x2F;SHA 密钥算法支持 12345678910111213#在当前账号家目录~/.ssh/config中添加以下信息Host gerrit.sys.gnacoh.net HostName gerrit.sys.gnaacoh.net Port 29418 HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa User xiaoming //更改为自己的用户名Host gerrit.gnacoh.net HostName gerrit.gnacoh.net Port 29418 HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa User xiaoming //更改为自己的用户名 二、采用仍被支持的密钥算法生成密钥对 1ssh-keygen.exe -t ed25519 -C &#x27;username@email.com&#x27; 附录： 一、OpenSSH Release Notes This release disables RSA signatures using the SHA-1 hash algorithmby default. This change has been made as the SHA-1 hash algorithm iscryptographically broken, and it is possible to create chosen-prefixhash collisions for &lt;USD$50K [1] For most users, this change should be invisible and there isno need to replace ssh-rsa keys. OpenSSH has supported RFC8332RSA&#x2F;SHA-256&#x2F;512 signatures since release 7.2 and existing ssh-rsa keyswill automatically use the stronger algorithm where possible. Incompatibility is more likely when connecting to older SSHimplementations that have not been upgraded or have not closely trackedimprovements in the SSH protocol. For these cases, it may be necessaryto selectively re-enable RSA&#x2F;SHA1 to allow connection and&#x2F;or userauthentication via the HostkeyAlgorithms and PubkeyAcceptedAlgorithmsoptions. For example, the following stanza in ~&#x2F;.ssh&#x2F;config will enableRSA&#x2F;SHA1 for host and user authentication for a single destination host: Host old-host HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa We recommend enabling RSA&#x2F;SHA1 only as a stopgap measure until legacyimplementations can be upgraded or reconfigured with another key type(such as ECDSA or Ed25519). [1] “SHA-1 is a Shambles: First Chosen-Prefix Collision on SHA-1 and Application to the PGP Web of Trust” Leurent, G and Peyrin, T (2020) https://eprint.iacr.org/2020/014.pdf Changes since OpenSSH 8.7 二、OpenSSH 版本查看 1234# windows内置ssh版本（cmd）：ssh -V# Git内置ssh版本（git bash）：ssh -V","categories":["版本管理"]},{"title":"Ubuntu配置域名解析","path":"/2022/11/02/Ubuntu配置域名解析/","content":"ubuntu设置域名服务器命令：resolvconf步骤一、创建一个文件&#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf.d&#x2F;base 1nameserver 域名服务器IP 步骤二、将dns信息刷新到服务配置里边 1reslovconf -u 步骤三、重启服务 1service resolvconf restart 方法二：1、修改&#x2F;etc&#x2F;network&#x2F;interfaces文件 123456789101112131415161718# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet static address 10.10.18.252 netmask 255.255.255.0 network 10.10.18.0 broadcast 10.10.18.255 gateway 10.10.18.1 # dns-* options are implemented by the resolvconf package, if installed # dns-nameservers 172.16.18.18 dns-nameservers 10.10.10.10 2、重启网卡ifdown eth0 &amp;&amp; ifup eth0"},{"path":"/notes/index.html","content":"实用工具 电子书刊及文档 权威网站 建站方案"}]